module.exports = [
  {
    id: "fibonacci",
    name: "Recursive Fibonacci",
    description:
      "Demonstrates recursive call stack depth with Fibonacci sequence calculation",
    code: [
      "public class Fibonacci {",
      "    public static int fib(int n) {",
      "        if (n <= 1) return n;",
      "        int left = fib(n - 1);",
      "        int right = fib(n - 2);",
      "        return left + right;",
      "    }",
      "",
      "    public static void main(String[] args) {",
      "        int result = fib(5);",
      '        System.out.println("Fibonacci(5) = " + result);',
      "    }",
      "}",
    ].join("\n"),
  },
  {
    id: "stack",
    name: "Stack (Push/Pop)",
    description:
      "Demonstrates stack data structure with push and pop operations",
    code: [
      "public class StackDemo {",
      "    static int[] data = new int[10];",
      "    static int top = -1;",
      "",
      "    public static void push(int value) {",
      "        top++;",
      "        data[top] = value;",
      "    }",
      "",
      "    public static int pop() {",
      "        int value = data[top];",
      "        data[top] = 0;",
      "        top--;",
      "        return value;",
      "    }",
      "",
      "    public static void main(String[] args) {",
      "        push(10);",
      "        push(20);",
      "        push(30);",
      "        int a = pop();",
      "        int b = pop();",
      '        System.out.println("Popped: " + a + " then " + b);',
      "    }",
      "}",
    ].join("\n"),
  },
  {
    id: "queue",
    name: "Queue (Enqueue/Dequeue)",
    description:
      "Demonstrates queue data structure with enqueue and dequeue operations",
    code: [
      "public class QueueDemo {",
      "    static int[] data = new int[10];",
      "    static int front = 0;",
      "    static int rear = -1;",
      "    static int size = 0;",
      "",
      "    public static void enqueue(int value) {",
      "        rear++;",
      "        data[rear] = value;",
      "        size++;",
      "    }",
      "",
      "    public static int dequeue() {",
      "        int value = data[front];",
      "        front++;",
      "        size--;",
      "        return value;",
      "    }",
      "",
      "    public static void main(String[] args) {",
      "        enqueue(10);",
      "        enqueue(20);",
      "        enqueue(30);",
      "        int a = dequeue();",
      "        int b = dequeue();",
      '        System.out.println("Dequeued: " + a + " then " + b);',
      "    }",
      "}",
    ].join("\n"),
  },
  {
    id: "bst",
    name: "BST Insertion",
    description: "Binary Search Tree node insertion with in-order traversal",
    code: [
      "public class BSTDemo {",
      "    static int[] keys  = new int[15];",
      "    static int[] left  = new int[15];",
      "    static int[] right = new int[15];",
      "    static int size = 0;",
      "    static int root = -1;",
      "",
      "    public static int newNode(int key) {",
      "        int idx = size;",
      "        keys[idx] = key;",
      "        left[idx] = -1;",
      "        right[idx] = -1;",
      "        size++;",
      "        return idx;",
      "    }",
      "",
      "    public static int insert(int node, int key) {",
      "        if (node == -1) return newNode(key);",
      "        if (key < keys[node]) {",
      "            left[node] = insert(left[node], key);",
      "        } else if (key > keys[node]) {",
      "            right[node] = insert(right[node], key);",
      "        }",
      "        return node;",
      "    }",
      "",
      "    public static void inorder(int node) {",
      "        if (node == -1) return;",
      "        inorder(left[node]);",
      '        System.out.print(keys[node] + \" \");',
      "        inorder(right[node]);",
      "    }",
      "",
      "    public static void main(String[] args) {",
      "        root = insert(root, 50);",
      "        root = insert(root, 30);",
      "        root = insert(root, 70);",
      "        root = insert(root, 20);",
      "        root = insert(root, 40);",
      "        root = insert(root, 60);",
      '        System.out.print("In-order: ");',
      "        inorder(root);",
      "        System.out.println();",
      "    }",
      "}",
    ].join("\n"),
  },
  {
    id: "bfs",
    name: "BFS on Graph",
    description: "Breadth-First Search traversal on an adjacency matrix graph",
    code: [
      "public class BFSDemo {",
      "    static int N = 6;",
      "    static int[][] adj = new int[6][6];",
      "    static boolean[] visited = new boolean[6];",
      "    static int[] queue = new int[6];",
      "    static int front = 0;",
      "    static int rear = 0;",
      "",
      "    public static void addEdge(int u, int v) {",
      "        adj[u][v] = 1;",
      "        adj[v][u] = 1;",
      "    }",
      "",
      "    public static void bfs(int start) {",
      "        visited[start] = true;",
      "        queue[rear] = start;",
      "        rear++;",
      "        while (front < rear) {",
      "            int node = queue[front];",
      "            front++;",
      '            System.out.print(node + " ");',
      "            for (int i = 0; i < N; i++) {",
      "                if (adj[node][i] == 1 && !visited[i]) {",
      "                    visited[i] = true;",
      "                    queue[rear] = i;",
      "                    rear++;",
      "                }",
      "            }",
      "        }",
      "    }",
      "",
      "    public static void main(String[] args) {",
      "        addEdge(0, 1);",
      "        addEdge(0, 2);",
      "        addEdge(1, 3);",
      "        addEdge(2, 4);",
      "        addEdge(3, 5);",
      '        System.out.print("BFS from 0: ");',
      "        bfs(0);",
      "        System.out.println();",
      "    }",
      "}",
    ].join("\n"),
  },
  {
    id: "mergesort",
    name: "Merge Sort",
    description: "Divide-and-conquer sorting with merge step visualization",
    code: [
      "public class MergeSortDemo {",
      "    static int[] temp = new int[8];",
      "",
      "    public static void merge(int[] arr, int l, int m, int r) {",
      "        int i = l, j = m + 1, k = l;",
      "        while (i <= m && j <= r) {",
      "            if (arr[i] <= arr[j]) {",
      "                temp[k] = arr[i];",
      "                i++;",
      "            } else {",
      "                temp[k] = arr[j];",
      "                j++;",
      "            }",
      "            k++;",
      "        }",
      "        while (i <= m) { temp[k] = arr[i]; i++; k++; }",
      "        while (j <= r) { temp[k] = arr[j]; j++; k++; }",
      "        for (int x = l; x <= r; x++) arr[x] = temp[x];",
      "    }",
      "",
      "    public static void mergeSort(int[] arr, int l, int r) {",
      "        if (l >= r) return;",
      "        int m = (l + r) / 2;",
      "        mergeSort(arr, l, m);",
      "        mergeSort(arr, m + 1, r);",
      "        merge(arr, l, m, r);",
      "    }",
      "",
      "    public static void main(String[] args) {",
      "        int[] arr = {38, 27, 43, 3, 9, 82, 10};",
      "        mergeSort(arr, 0, arr.length - 1);",
      '        System.out.print("Sorted: ");',
      '        for (int v : arr) System.out.print(v + " ");',
      "        System.out.println();",
      "    }",
      "}",
    ].join("\n"),
  },
];
